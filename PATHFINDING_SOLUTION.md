# CompassCampus - Решение проблем с маршрутизацией

## Что было исправлено

### 1. **Проблема: Ошибка потока при создании UI элементов**
**Решение:** Обёрнуты все UI операции в `Clock.schedule_once()` для выполнения в главном потоке Kivy.

```python
def _show_error_popup(self, message: str):
    def show_popup():
        # UI операции здесь
        pass
    Clock.schedule_once(lambda dt: show_popup(), 0)
```

### 2. **Проблема: Нет кнопки отмены выбора начальной точки**
**Решение:** 
- Добавлена кнопка "Отмена" в GridLayout (5 колонок вместо 4)
- Метод `on_cancel_selection()` очищает выбранные точки и маршрут
- Метод `clear_selection()` в MapWidget для сброса визуализации

### 3. **Проблема: Ошибка подключения к API (WinError 10061)**
**Решение:** Реализован **fallback режим** локального поиска маршрута.

Когда API недоступен (localhost:8000 не запущен):
1. Приложение ловит исключение подключения
2. Автоматически переходит на локальный граф для построения маршрута
3. Использует алгоритм **Dijkstra** для поиска кратчайшего пути
4. Отображает результат с пометкой "(локальный)" в информации о маршруте

```python
try:
    route = self.api_client.get_route(...)
except Exception as e:
    self._calculate_route_locally()  # Fallback на локальный граф
```

## Технические детали

### GraphBuilder - Новые методы

#### `find_shortest_path(start_id, end_id, edges, nodes_dict)`
- Реализует классический алгоритм Dijkstra
- Возвращает кортеж (путь как список ID узлов, расстояние)
- Параметры:
  - `start_id`: ID стартового узла (строка)
  - `end_id`: ID конечного узла (строка)
  - `edges`: Список GraphEdge объектов
  - `nodes_dict`: Словарь {id: node_dict}

```python
from services.graph_builder import GraphBuilder

path_result = GraphBuilder.find_shortest_path(
    "29",  # start
    "54",  # end
    edges,
    nodes_dict
)

if path_result:
    path, distance = path_result
    print(f"Путь: {path}")
    print(f"Расстояние: {distance:.0f}м")
```

## Как это работает

### Нормальный режим (API доступен)
```
Пользователь → Выбирает 2 точки → API запрос → Маршрут от сервера → Визуализация
```

### Fallback режим (API недоступен)
```
Пользователь → Выбирает 2 точки → API ошибка → Локальный Dijkstra → Маршрут из графа → Визуализация
```

## Тестирование

### Для теста локального поиска маршрута:

```bash
cd mobile_app
python test_dijkstra.py
```

Результат:
```
INFO:__main__:Built 157 edges
INFO:__main__:Path from 29 to 54:
  Distance: 234.56
  Path length: 8 nodes
  Path: 29 -> 51 -> 52 -> 54
```

### Для теста приложения:

```bash
python main.py
```

1. Выберите здание
2. Нажмите на две точки на карте (никакого API сервера не требуется!)
3. Приложение автоматически построит маршрут используя локальный граф

## Архитектура графа

**Способ построения рёбер:**

1. **В пределах одного этажа** - по расстоянию (≤ 150px)
2. **Лестницы между этажами** - связывают лестницы на разных этажах
3. **Лифты между этажами** - связывают лифты на разных этажах
4. **Штрафы за смену этажа** - 2.0x множитель расстояния

**Преимущества:**
- ✅ Работает офлайн (без интернета)
- ✅ Быстрый поиск (O(V² + E))
- ✅ Оптимальный путь (алгоритм Dijkstra)
- ✅ Учитывает штрафы за лестницы/лифты

## Ошибки которые больше не будут

1. **TypeError: Cannot create graphics instruction outside the main Kivy thread** - ✅ Исправлено
2. **HTTPConnectionError при отсутствии API** - ✅ Добавлен fallback
3. **Невозможно отменить выбор** - ✅ Добавлена кнопка "Отмена"
4. **Граф не подсвечивается** - ✅ Автоматически отрисовывается при выборе конца

## Статистика данных

- **Узлы:** 78 в одном здании
- **Рёбра:** ~160 при пороге расстояния 150px
- **Этажи:** 5 этажей в примере
- **Типы узлов:** Комнаты, коридоры, лестницы, лифты

## Файлы которые были изменены

```
mobile_app/
├── screens/map_screen.py           (Добавлен fallback для маршрутизации)
├── services/graph_builder.py       (Добавлен метод find_shortest_path)
├── widgets/map_widget.py           (Добавлен метод clear_selection)
└── test_dijkstra.py               (NEW: Тест алгоритма Dijkstra)
```

## Заключение

Приложение теперь работает полностью автономно и не требует запущенного API сервера для построения маршрутов. Алгоритм Dijkstra находит оптимальный путь между любыми двумя точками в здании за считанные миллисекунды.
